// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query_user.sql

package sqlc

import (
	"context"
	"net/netip"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    email,
    password_hash,
    username,
    first_name,
    last_name,
    phone_number,
    timezone,
    language
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
) RETURNING id, email, password_hash, username, first_name, last_name, full_name, phone_number, date_of_birth, avatar_url, is_active, is_verified, is_deleted, email_verified_at, verification_token, verification_token_expires_at, reset_token, reset_token_expires_at, last_login_at, last_login_ip, failed_login_attempts, locked_until, two_factor_enabled, two_factor_secret, timezone, language, metadata, created_at, updated_at, deleted_at
`

type CreateUserParams struct {
	Email        string
	PasswordHash string
	Username     pgtype.Text
	FirstName    pgtype.Text
	LastName     pgtype.Text
	PhoneNumber  pgtype.Text
	Timezone     pgtype.Text
	Language     pgtype.Text
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.PasswordHash,
		arg.Username,
		arg.FirstName,
		arg.LastName,
		arg.PhoneNumber,
		arg.Timezone,
		arg.Language,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.FullName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.AvatarUrl,
		&i.IsActive,
		&i.IsVerified,
		&i.IsDeleted,
		&i.EmailVerifiedAt,
		&i.VerificationToken,
		&i.VerificationTokenExpiresAt,
		&i.ResetToken,
		&i.ResetTokenExpiresAt,
		&i.LastLoginAt,
		&i.LastLoginIp,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.TwoFactorEnabled,
		&i.TwoFactorSecret,
		&i.Timezone,
		&i.Language,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT
    u.id, u.email, u.password_hash, u.username, u.first_name, u.last_name, u.full_name, u.phone_number, u.date_of_birth, u.avatar_url, u.is_active, u.is_verified, u.is_deleted, u.email_verified_at, u.verification_token, u.verification_token_expires_at, u.reset_token, u.reset_token_expires_at, u.last_login_at, u.last_login_ip, u.failed_login_attempts, u.locked_until, u.two_factor_enabled, u.two_factor_secret, u.timezone, u.language, u.metadata, u.created_at, u.updated_at, u.deleted_at,
    COALESCE(
        JSON_AGG(
            JSON_BUILD_OBJECT(
                'id', r.id,
                'name', r.name,
                'description', r.description
            )
        ) FILTER (WHERE r.id IS NOT NULL),
        '[]'::json
    ) AS roles
FROM users u
LEFT JOIN user_roles ur ON u.id = ur.user_id
LEFT JOIN roles r ON ur.role_id = r.id
WHERE u.id = $1
GROUP BY u.id
LIMIT 1
`

type GetUserRow struct {
	ID                         uuid.UUID
	Email                      string
	PasswordHash               string
	Username                   pgtype.Text
	FirstName                  pgtype.Text
	LastName                   pgtype.Text
	FullName                   pgtype.Text
	PhoneNumber                pgtype.Text
	DateOfBirth                pgtype.Date
	AvatarUrl                  pgtype.Text
	IsActive                   bool
	IsVerified                 bool
	IsDeleted                  bool
	EmailVerifiedAt            pgtype.Timestamptz
	VerificationToken          pgtype.Text
	VerificationTokenExpiresAt pgtype.Timestamptz
	ResetToken                 pgtype.Text
	ResetTokenExpiresAt        pgtype.Timestamptz
	LastLoginAt                pgtype.Timestamptz
	LastLoginIp                *netip.Addr
	FailedLoginAttempts        pgtype.Int4
	LockedUntil                pgtype.Timestamptz
	TwoFactorEnabled           bool
	TwoFactorSecret            pgtype.Text
	Timezone                   pgtype.Text
	Language                   pgtype.Text
	Metadata                   []byte
	CreatedAt                  pgtype.Timestamptz
	UpdatedAt                  pgtype.Timestamptz
	DeletedAt                  pgtype.Timestamptz
	Roles                      interface{}
}

func (q *Queries) GetUser(ctx context.Context, id uuid.UUID) (GetUserRow, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i GetUserRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.FullName,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.AvatarUrl,
		&i.IsActive,
		&i.IsVerified,
		&i.IsDeleted,
		&i.EmailVerifiedAt,
		&i.VerificationToken,
		&i.VerificationTokenExpiresAt,
		&i.ResetToken,
		&i.ResetTokenExpiresAt,
		&i.LastLoginAt,
		&i.LastLoginIp,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.TwoFactorEnabled,
		&i.TwoFactorSecret,
		&i.Timezone,
		&i.Language,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Roles,
	)
	return i, err
}

const listUsers = `-- name: ListUsers :many
SELECT
    u.id, u.email, u.password_hash, u.username, u.first_name, u.last_name, u.full_name, u.phone_number, u.date_of_birth, u.avatar_url, u.is_active, u.is_verified, u.is_deleted, u.email_verified_at, u.verification_token, u.verification_token_expires_at, u.reset_token, u.reset_token_expires_at, u.last_login_at, u.last_login_ip, u.failed_login_attempts, u.locked_until, u.two_factor_enabled, u.two_factor_secret, u.timezone, u.language, u.metadata, u.created_at, u.updated_at, u.deleted_at,
    COALESCE(
        JSON_AGG(
            JSON_BUILD_OBJECT(
                'id', r.id,
                'name', r.name,
                'description', r.description
            )
        ) FILTER (WHERE r.id IS NOT NULL),
        '[]'::json
    ) AS roles
FROM users u
LEFT JOIN user_roles ur ON u.id = ur.user_id
LEFT JOIN roles r ON ur.role_id = r.id
GROUP BY u.id
ORDER BY u.created_at DESC
LIMIT $1
OFFSET $2
`

type ListUsersParams struct {
	Limit  int32
	Offset int32
}

type ListUsersRow struct {
	ID                         uuid.UUID
	Email                      string
	PasswordHash               string
	Username                   pgtype.Text
	FirstName                  pgtype.Text
	LastName                   pgtype.Text
	FullName                   pgtype.Text
	PhoneNumber                pgtype.Text
	DateOfBirth                pgtype.Date
	AvatarUrl                  pgtype.Text
	IsActive                   bool
	IsVerified                 bool
	IsDeleted                  bool
	EmailVerifiedAt            pgtype.Timestamptz
	VerificationToken          pgtype.Text
	VerificationTokenExpiresAt pgtype.Timestamptz
	ResetToken                 pgtype.Text
	ResetTokenExpiresAt        pgtype.Timestamptz
	LastLoginAt                pgtype.Timestamptz
	LastLoginIp                *netip.Addr
	FailedLoginAttempts        pgtype.Int4
	LockedUntil                pgtype.Timestamptz
	TwoFactorEnabled           bool
	TwoFactorSecret            pgtype.Text
	Timezone                   pgtype.Text
	Language                   pgtype.Text
	Metadata                   []byte
	CreatedAt                  pgtype.Timestamptz
	UpdatedAt                  pgtype.Timestamptz
	DeletedAt                  pgtype.Timestamptz
	Roles                      interface{}
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]ListUsersRow, error) {
	rows, err := q.db.Query(ctx, listUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersRow
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.PasswordHash,
			&i.Username,
			&i.FirstName,
			&i.LastName,
			&i.FullName,
			&i.PhoneNumber,
			&i.DateOfBirth,
			&i.AvatarUrl,
			&i.IsActive,
			&i.IsVerified,
			&i.IsDeleted,
			&i.EmailVerifiedAt,
			&i.VerificationToken,
			&i.VerificationTokenExpiresAt,
			&i.ResetToken,
			&i.ResetTokenExpiresAt,
			&i.LastLoginAt,
			&i.LastLoginIp,
			&i.FailedLoginAttempts,
			&i.LockedUntil,
			&i.TwoFactorEnabled,
			&i.TwoFactorSecret,
			&i.Timezone,
			&i.Language,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Roles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
